/// @file include-private/xed3-phash-vv3.h

// This file was automatically generated.
// Do not edit this file.

#if !defined(INCLUDE_PRIVATE_XED3_PHASH_VV3_H)
# define INCLUDE_PRIVATE_XED3_PHASH_VV3_H
/*BEGIN_LEGAL

Copyright (c) 2021 Intel Corporation

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  
END_LEGAL */
#include "xed-internal-header.h"
#include "xed3-operand-lu.h"
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x85_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x86_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x87_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x8e_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x8f_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x95_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x96_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x97_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x9e_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x9f_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xa2_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xa3_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xa6_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xb6_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xc0_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xc1_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xc2_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xc3_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xcc_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xcd_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xce_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xcf_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xec_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xed_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xee_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xef_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x1_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x2_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x12_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x80_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x81_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x82_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x83_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x90_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x91_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x92_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x93_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x94_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x95_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x96_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x97_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x98_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x99_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x9a_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x9b_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xc1_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xc2_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xc3_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xc6_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xc7_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xcb_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xd1_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xd2_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xd3_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xd6_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xd7_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xdb_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xe1_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xe2_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xe3_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xopA_opcode0x10_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xopA_opcode0x12_vv3(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x85_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0x85 VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2190},
/*h(1)=1 XOPV 0x85 VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2191}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x86_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0x86 VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2192},
/*h(1)=1 XOPV 0x86 VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2193}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x87_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0x87 VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2194},
/*h(1)=1 XOPV 0x87 VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2195}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x8e_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0x8E VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2242},
/*h(1)=1 XOPV 0x8E VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2243}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x8f_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0x8F VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2244},
/*h(1)=1 XOPV 0x8F VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2245}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x95_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0x95 VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2196},
/*h(1)=1 XOPV 0x95 VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2197}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x96_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0x96 VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2198},
/*h(1)=1 XOPV 0x96 VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2199}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x97_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0x97 VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2200},
/*h(1)=1 XOPV 0x97 VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2201}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x9e_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0x9E VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2246},
/*h(1)=1 XOPV 0x9E VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2247}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0x9f_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0x9F VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2248},
/*h(1)=1 XOPV 0x9F VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2249}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xa2_vv3(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[14] = {
/*h(0)=0 XOPV 0xA2 VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {0, 2202},
/*h(18)=1 XOPV 0xA2 VNP W1 VL256  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {18, 2208},
/*empty slot1 */ {0,0},
/*h(2)=3 XOPV 0xA2 VNP W1 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2, 2204},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(17)=7 XOPV 0xA2 VNP W0 VL256  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {17, 2207},
/*h(1)=8 XOPV 0xA2 VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {1, 2203},
/*empty slot1 */ {0,0},
/*h(19)=10 XOPV 0xA2 VNP W1 VL256  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {19, 2209},
/*h(3)=11 XOPV 0xA2 VNP W1 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {3, 2205},
/*h(16)=12 XOPV 0xA2 VNP W0 VL256  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {16, 2206},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 14ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xa3_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(0)=0 XOPV 0xA3 VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2210},
/*h(1)=1 XOPV 0xA3 VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2211},
/*h(2)=2 XOPV 0xA3 VNP W1 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2212},
/*h(3)=3 XOPV 0xA3 VNP W1 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2213}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xa6_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0xA6 VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2214},
/*h(1)=1 XOPV 0xA6 VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2215}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xb6_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0xB6 VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2216},
/*h(1)=1 XOPV 0xB6 VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2217}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xc0_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xC0 VNP W0 VL128 NOVSR XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2218},
/*h(13)=1 XOPV 0xC0 VNP W0 VL128 NOVSR XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2219}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xc1_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xC1 VNP W0 VL128 NOVSR XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2224},
/*h(13)=1 XOPV 0xC1 VNP W0 VL128 NOVSR XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2225}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xc2_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xC2 VNP W0 VL128 NOVSR XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2230},
/*h(13)=1 XOPV 0xC2 VNP W0 VL128 NOVSR XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2231}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xc3_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xC3 VNP W0 VL128 NOVSR XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2236},
/*h(13)=1 XOPV 0xC3 VNP W0 VL128 NOVSR XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2237}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xcc_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0xCC VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2250},
/*h(1)=1 XOPV 0xCC VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2251}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xcd_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0xCD VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2252},
/*h(1)=1 XOPV 0xCD VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2253}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xce_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0xCE VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2254},
/*h(1)=1 XOPV 0xCE VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2255}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xcf_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0xCF VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2256},
/*h(1)=1 XOPV 0xCF VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2257}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xec_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0xEC VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2258},
/*h(1)=1 XOPV 0xEC VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2259}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xed_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0xED VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2260},
/*h(1)=1 XOPV 0xED VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2261}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xee_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0xEE VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2262},
/*h(1)=1 XOPV 0xEE VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2263}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop8_opcode0xef_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(0)=0 XOPV 0xEF VNP W0 VL128  XMAP8 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2264},
/*h(1)=1 XOPV 0xEF VNP W0 VL128  XMAP8 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2265}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x1_vv3(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[55] = {
/*h(34)=0 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b100] RM[nnn] MODRM()*/ {34, 2356},
/*h(13)=1 XOPV 0x01 VNP mode64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b001] RM[nnn]*/ {13, 2347},
/*empty slot1 */ {0,0},
/*h(26)=3 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b011] RM[nnn] MODRM()*/ {26, 2352},
/*h(60)=4 XOPV 0x01 VNP mode64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b111] RM[nnn] MODRM()*/ {60, 2369},
/*empty slot1 */ {0,0},
/*h(18)=6 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b010] RM[nnn] MODRM()*/ {18, 2348},
/*h(52)=7 XOPV 0x01 VNP mode64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b110] RM[nnn] MODRM()*/ {52, 2365},
/*empty slot1 */ {0,0},
/*h(10)=9 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b001] RM[nnn] MODRM()*/ {10, 2344},
/*h(44)=10 XOPV 0x01 VNP mode64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b101] RM[nnn] MODRM()*/ {44, 2361},
/*empty slot1 */ {0,0},
/*h(57)=12 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b111] RM[nnn]*/ {57, 2370},
/*h(36)=13 XOPV 0x01 VNP mode64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b100] RM[nnn] MODRM()*/ {36, 2357},
/*empty slot1 */ {0,0},
/*h(49)=15 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b110] RM[nnn]*/ {49, 2366},
/*h(28)=16 XOPV 0x01 VNP mode64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b011] RM[nnn] MODRM()*/ {28, 2353},
/*empty slot1 */ {0,0},
/*h(41)=18 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b101] RM[nnn]*/ {41, 2362},
/*h(20)=19 XOPV 0x01 VNP mode64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b010] RM[nnn] MODRM()*/ {20, 2349},
/*empty slot1 */ {0,0},
/*h(33)=21 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b100] RM[nnn]*/ {33, 2358},
/*h(12)=22 XOPV 0x01 VNP mode64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b001] RM[nnn] MODRM()*/ {12, 2345},
/*empty slot1 */ {0,0},
/*h(25)=24 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b011] RM[nnn]*/ {25, 2354},
/*h(59)=25 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b111] RM[nnn]*/ {59, 2370},
/*empty slot1 */ {0,0},
/*h(17)=27 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b010] RM[nnn]*/ {17, 2350},
/*h(51)=28 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b110] RM[nnn]*/ {51, 2366},
/*empty slot1 */ {0,0},
/*h(9)=30 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b001] RM[nnn]*/ {9, 2346},
/*h(43)=31 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b101] RM[nnn]*/ {43, 2362},
/*empty slot1 */ {0,0},
/*h(56)=33 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b111] RM[nnn] MODRM()*/ {56, 2368},
/*h(35)=34 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b100] RM[nnn]*/ {35, 2358},
/*empty slot1 */ {0,0},
/*h(48)=36 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b110] RM[nnn] MODRM()*/ {48, 2364},
/*h(27)=37 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b011] RM[nnn]*/ {27, 2354},
/*h(61)=38 XOPV 0x01 VNP mode64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b111] RM[nnn]*/ {61, 2371},
/*h(40)=39 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b101] RM[nnn] MODRM()*/ {40, 2360},
/*h(19)=40 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b010] RM[nnn]*/ {19, 2350},
/*h(53)=41 XOPV 0x01 VNP mode64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b110] RM[nnn]*/ {53, 2367},
/*h(32)=42 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b100] RM[nnn] MODRM()*/ {32, 2356},
/*h(11)=43 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b001] RM[nnn]*/ {11, 2346},
/*h(45)=44 XOPV 0x01 VNP mode64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b101] RM[nnn]*/ {45, 2363},
/*h(24)=45 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b011] RM[nnn] MODRM()*/ {24, 2352},
/*h(58)=46 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b111] RM[nnn] MODRM()*/ {58, 2368},
/*h(37)=47 XOPV 0x01 VNP mode64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b100] RM[nnn]*/ {37, 2359},
/*h(16)=48 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b010] RM[nnn] MODRM()*/ {16, 2348},
/*h(50)=49 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b110] RM[nnn] MODRM()*/ {50, 2364},
/*h(29)=50 XOPV 0x01 VNP mode64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b011] RM[nnn]*/ {29, 2355},
/*h(8)=51 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b001] RM[nnn] MODRM()*/ {8, 2344},
/*h(42)=52 XOPV 0x01 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b101] RM[nnn] MODRM()*/ {42, 2360},
/*h(21)=53 XOPV 0x01 VNP mode64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b010] RM[nnn]*/ {21, 2351},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REG_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 55ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x2_vv3(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[17] = {
/*h(13)=0 XOPV 0x02 VNP mode64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b001] RM[nnn]*/ {13, 2375},
/*empty slot1 */ {0,0},
/*h(52)=2 XOPV 0x02 VNP mode64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b110] RM[nnn] MODRM()*/ {52, 2377},
/*h(10)=3 XOPV 0x02 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b001] RM[nnn] MODRM()*/ {10, 2372},
/*h(49)=4 XOPV 0x02 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b110] RM[nnn]*/ {49, 2378},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(12)=7 XOPV 0x02 VNP mode64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b001] RM[nnn] MODRM()*/ {12, 2373},
/*h(51)=8 XOPV 0x02 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b110] RM[nnn]*/ {51, 2378},
/*h(9)=9 XOPV 0x02 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b001] RM[nnn]*/ {9, 2374},
/*empty slot1 */ {0,0},
/*h(48)=11 XOPV 0x02 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b110] RM[nnn] MODRM()*/ {48, 2376},
/*h(53)=12 XOPV 0x02 VNP mode64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b110] RM[nnn]*/ {53, 2379},
/*h(11)=13 XOPV 0x02 VNP not64 VL128  XMAP9 MOD[0b11] MOD=3 REG[0b001] RM[nnn]*/ {11, 2374},
/*empty slot1 */ {0,0},
/*h(50)=15 XOPV 0x02 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b110] RM[nnn] MODRM()*/ {50, 2376},
/*h(8)=16 XOPV 0x02 VNP not64 VL128  XMAP9 MOD[mm] MOD!=3 REG[0b001] RM[nnn] MODRM()*/ {8, 2372}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REG_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 17ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x12_vv3(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(49)=0 XOPV 0x12 VNP VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[0b000] RM[nnn]*/ {49, 2380},
/*h(51)=1 XOPV 0x12 VNP VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[0b001] RM[nnn]*/ {51, 2381}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REG_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-1));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x80_vv3(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(13)=0 XOPV 0x80 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {13, 2267},
/*h(12)=1 XOPV 0x80 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {12, 2266},
/*h(77)=2 XOPV 0x80 VNP W0 VL256 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {77, 2269},
/*h(76)=3 XOPV 0x80 VNP W0 VL256 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {76, 2268}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-2));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x81_vv3(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(13)=0 XOPV 0x81 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {13, 2271},
/*h(12)=1 XOPV 0x81 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {12, 2270},
/*h(77)=2 XOPV 0x81 VNP W0 VL256 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {77, 2273},
/*h(76)=3 XOPV 0x81 VNP W0 VL256 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {76, 2272}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-2));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x82_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0x82 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2274},
/*h(13)=1 XOPV 0x82 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2275}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x83_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0x83 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2276},
/*h(13)=1 XOPV 0x83 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2277}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x90_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(0)=0 XOPV 0x90 VNP W0 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2220},
/*h(1)=1 XOPV 0x90 VNP W0 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2221},
/*h(2)=2 XOPV 0x90 VNP W1 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2222},
/*h(3)=3 XOPV 0x90 VNP W1 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2223}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x91_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(0)=0 XOPV 0x91 VNP W0 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2226},
/*h(1)=1 XOPV 0x91 VNP W0 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2227},
/*h(2)=2 XOPV 0x91 VNP W1 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2228},
/*h(3)=3 XOPV 0x91 VNP W1 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2229}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x92_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(0)=0 XOPV 0x92 VNP W0 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2232},
/*h(1)=1 XOPV 0x92 VNP W0 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2233},
/*h(2)=2 XOPV 0x92 VNP W1 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2234},
/*h(3)=3 XOPV 0x92 VNP W1 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2235}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x93_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(0)=0 XOPV 0x93 VNP W0 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2238},
/*h(1)=1 XOPV 0x93 VNP W0 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2239},
/*h(2)=2 XOPV 0x93 VNP W1 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2240},
/*h(3)=3 XOPV 0x93 VNP W1 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2241}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x94_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(0)=0 XOPV 0x94 VNP W0 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2278},
/*h(1)=1 XOPV 0x94 VNP W0 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2279},
/*h(2)=2 XOPV 0x94 VNP W1 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2280},
/*h(3)=3 XOPV 0x94 VNP W1 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2281}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x95_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(0)=0 XOPV 0x95 VNP W0 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2282},
/*h(1)=1 XOPV 0x95 VNP W0 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2283},
/*h(2)=2 XOPV 0x95 VNP W1 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2284},
/*h(3)=3 XOPV 0x95 VNP W1 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2285}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x96_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(0)=0 XOPV 0x96 VNP W0 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2286},
/*h(1)=1 XOPV 0x96 VNP W0 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2287},
/*h(2)=2 XOPV 0x96 VNP W1 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2288},
/*h(3)=3 XOPV 0x96 VNP W1 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2289}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x97_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(0)=0 XOPV 0x97 VNP W0 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2290},
/*h(1)=1 XOPV 0x97 VNP W0 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2291},
/*h(2)=2 XOPV 0x97 VNP W1 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2292},
/*h(3)=3 XOPV 0x97 VNP W1 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2293}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x98_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(0)=0 XOPV 0x98 VNP W0 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2320},
/*h(1)=1 XOPV 0x98 VNP W0 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2321},
/*h(2)=2 XOPV 0x98 VNP W1 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2322},
/*h(3)=3 XOPV 0x98 VNP W1 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2323}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x99_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(0)=0 XOPV 0x99 VNP W0 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2324},
/*h(1)=1 XOPV 0x99 VNP W0 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2325},
/*h(2)=2 XOPV 0x99 VNP W1 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2326},
/*h(3)=3 XOPV 0x99 VNP W1 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2327}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x9a_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(0)=0 XOPV 0x9A VNP W0 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2328},
/*h(1)=1 XOPV 0x9A VNP W0 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2329},
/*h(2)=2 XOPV 0x9A VNP W1 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2330},
/*h(3)=3 XOPV 0x9A VNP W1 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2331}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0x9b_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(0)=0 XOPV 0x9B VNP W0 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2332},
/*h(1)=1 XOPV 0x9B VNP W0 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2333},
/*h(2)=2 XOPV 0x9B VNP W1 VL128  XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2334},
/*h(3)=3 XOPV 0x9B VNP W1 VL128  XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2335}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xc1_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xC1 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2294},
/*h(13)=1 XOPV 0xC1 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2295}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xc2_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xC2 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2296},
/*h(13)=1 XOPV 0xC2 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2297}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xc3_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xC3 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2298},
/*h(13)=1 XOPV 0xC3 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2299}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xc6_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xC6 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2300},
/*h(13)=1 XOPV 0xC6 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2301}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xc7_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xC7 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2302},
/*h(13)=1 XOPV 0xC7 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2303}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xcb_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xCB VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2336},
/*h(13)=1 XOPV 0xCB VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2337}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xd1_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xD1 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2304},
/*h(13)=1 XOPV 0xD1 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2305}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xd2_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xD2 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2306},
/*h(13)=1 XOPV 0xD2 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2307}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xd3_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xD3 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2308},
/*h(13)=1 XOPV 0xD3 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2309}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xd6_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xD6 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2310},
/*h(13)=1 XOPV 0xD6 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2311}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xd7_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xD7 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2312},
/*h(13)=1 XOPV 0xD7 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2313}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xdb_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xDB VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2338},
/*h(13)=1 XOPV 0xDB VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2339}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xe1_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xE1 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2314},
/*h(13)=1 XOPV 0xE1 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2315}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xe2_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xE2 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2316},
/*h(13)=1 XOPV 0xE2 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2317}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xop9_opcode0xe3_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(12)=0 XOPV 0xE3 VNP W0 VL128 NOVSR XMAP9 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2318},
/*h(13)=1 XOPV 0xE3 VNP W0 VL128 NOVSR XMAP9 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2319}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 12;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xopA_opcode0x10_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[6] = {
/*h(24)=0 XOPV 0x10 VNP not64 VL128 NOVSR XMAPA MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM32()*/ {2340},
/*h(25)=1 XOPV 0x10 VNP not64 VL128 NOVSR XMAPA MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM32()*/ {2342},
/*h(26)=2 XOPV 0x10 VNP not64 VL128 NOVSR XMAPA MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM32()*/ {2340},
/*h(27)=3 XOPV 0x10 VNP not64 VL128 NOVSR XMAPA MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM32()*/ {2342},
/*h(28)=4 XOPV 0x10 VNP mode64  VL128 NOVSR XMAPA MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM32()*/ {2341},
/*h(29)=5 XOPV 0x10 VNP mode64 VL128 NOVSR XMAPA MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM32()*/ {2343}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 24;
if(hidx <= 5) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_mapamd_xopA_opcode0x12_vv3(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(0)=0 XOPV 0x12 VNP  VL128  XMAPA MOD[mm] MOD!=3 REG[0b000] RM[nnn] MODRM() UIMM32()*/ {2382},
/*h(1)=1 XOPV 0x12 VNP  VL128  XMAPA MOD[0b11] MOD=3 REG[0b000] RM[nnn] UIMM32()*/ {2383},
/*h(2)=2 XOPV 0x12 VNP VL128  XMAPA MOD[mm] MOD!=3 REG[0b001] RM[nnn] MODRM() UIMM32()*/ {2384},
/*h(3)=3 XOPV 0x12 VNP VL128  XMAPA MOD[0b11] MOD=3 REG[0b001] RM[nnn] UIMM32()*/ {2385}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REG_VEX_PREFIX_VL(d);
hidx = key - 0;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
#endif
